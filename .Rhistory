print(ridgelm(d,0.2))
# library(rectools)
#
# getInstEval()
# set.seed(9999)
# idxs <- sample(1:nrow(ivl),5000)
# trn <- ivl[-idxs,]
# tst <- ivl[idxs,]
#
# # matrix factorization
# mfout <- trainReco(trn)
# preds.mf <- predict(mfout,tst[,-3])
# mean(abs(preds.mf - tst[,3]),na.rm=T)
#
# # method of moments
# mmout <- trainMM(trn)
# preds.mm <- predict(mmout,tst[,-3])
# mean(abs(preds.mm - tst[,3]),na.rm=T)
#
# # predict from alpha_i, beta_i, linear model
# udconv <- RStoReg(ivl)
# udconvout1 <- lm(y ~ .,data=udconv[-idxs,])
# preds.conv1 <- predict(udconvout1,udconv[idxs,])
# mean(abs(preds.conv1 - tst[,3]),na.rm=T)
#            [,1]
# [1,]  6.5701554
# [2,] -0.1712036
# [3,] -1.5710789
ridgelm<- function(xy,s)
{
A <- xy[,1:2]
A <- cbind(c(1,1,1,1), A)
D <- xy[,3]
At <- t(A)
A_At <- At %*% A
At_D <- At %*% D
A_At_plus_sI <- solve(A_At + s * diag(3))
A_At_plus_sI %*% At_D
}
d <- cbind(c(5,1,2,8),c(0,2,2,1),c(8,3,4,2))
print(ridgelm(d,0.2))
setwd("C:/Users/caxia/Desktop/Congressional-Voting-Missing-Data-Filling")
ratings <- read.table('house-votes-84.data.txt', sep=',')
# find number of na for each col
numNA <- rep(0,ncol(ratings))
for (i in 1:length(numNA))
numNA[i] <- sum(ratings[,i] == '?')
# output missing value count for each column"
names(numNA) <- sprintf("col%s",seq(1:length(numNA)))
print(numNA)
# create testing and training data
train_df <- data.frame(matrix(ncol = 4, nrow = 0))
test_df <- data.frame(matrix(ncol = 4, nrow = 0))
colnames(train_df) <- c("userID", "itemID", "rating", "class")
colnames(test_df) <- c("userID", "itemID", "rating", "class")
for (rowID in 1:nrow(ratings)) {
row <- ratings[rowID,]
for (i in 2:17) {
if (sum(row=="?") == 16)
train_df <- rbind(train_df, data.frame(userID=rowID, itemID=NA, rating=NA,
class=as.numeric(row[1])))
if (row[i] == '?')
test_df <- rbind(test_df, data.frame(userID=rowID, itemID=i, rating=NA, class=as.numeric(row[1])))
else
train_df <- rbind(train_df, data.frame(userID=rowID, itemID=i, rating=as.numeric(row[i]),
class=as.numeric(row[1])))
}
}
library('rectools')
#---------------------
# KNN Approach
#---------------------
# create train and test data
# set the seed to make train test split reproducible
set.seed(123)
trainIdx <- sample(seq_len(nrow(train_df)), size=floor(0.80 * nrow(train_df)))
train <- train_df[trainIdx,]
test <- train_df[-trainIdx,]
ud <- formUserData(train[,1:3])
# predict the training data and find the MAPE
Ks <- seq(1, 100, by=4)
MAPEs <- vector(mode="numeric", length=0)
for (k in Ks) {
prediction <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], k)))
MAPEs <- c(MAPEs, mean(abs((prediction - test[,3])),na.rm=T))
}
seq(1,5)
Ks <- seq(1, 5)
MAPEs <- vector(mode="numeric", length=0)
for (k in Ks) {
prediction <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], k)))
MAPEs <- c(MAPEs, mean(abs((prediction - test[,3])),na.rm=T))
}
paste("Min MAPE:", min(MAPEs))
paste("Best k found:", 4*which(MAPEs==min(MAPEs)))
optimal_k <- 4*which(MAPEs==min(MAPEs))
library('ggplot2')
print("- Creating graphs for MAPE vs K...")
mape_vs_k <- data.frame(k=Ks, mape=MAPEs)
qplot(x=Ks, y=MAPEs, data=mape_vs_k, geom="line")
ggsave('mean_vs_k.png')
ptm <- proc.time()
# output minimum MAPE and the k for that
paste("Min MAPE:", min(MAPEs))
paste("Best k found:", 4*which(MAPEs==min(MAPEs)))
optimal_k <- 4*which(MAPEs==min(MAPEs))
proc.time() - ptm
ptm <- proc.time()
# output minimum MAPE and the k for that
paste("Min MAPE:", min(MAPEs))
paste("Best k found:", 4*which(MAPEs==min(MAPEs)))
optimal_k <- 4*which(MAPEs==min(MAPEs))
proc.time() - ptm
ptm <- proc.time()
# output minimum MAPE and the k for that
paste("Min MAPE:", min(MAPEs))
paste("Best k found:", 4*which(MAPEs==min(MAPEs)))
optimal_k <- 4*which(MAPEs==min(MAPEs))
print(proc.time() - ptm)
ptm <- proc.time()
Ks <- seq(1, 3)
MAPEs <- vector(mode="numeric", length=0)
for (k in Ks) {
prediction <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], k)))
MAPEs <- c(MAPEs, mean(abs((prediction - test[,3])),na.rm=T))
}
print(proc.time() - ptm)
ptm <- proc.time()
Ks <- seq(1, 3)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
MAPEs <- apply(prediction, function(pred) mean(abs((pred - test[,3])),na.rm=T))
print(proc.time() - ptm)
MAPEs <- apply(prediction, 1, function(pred) mean(abs((pred - test[,3])),na.rm=T))
MAPEs <- apply(predictions, 1, function(pred) mean(abs((pred - test[,3])),na.rm=T))
predictions
View(predictions)
names(predictions)
predictions[[1]]
unlist(predictions[[1]])
unlist(predictions)
ptm <- proc.time()
Ks <- seq(1, 3)
predict_helper <- function(row, k) round(predict(ud, ud[[row[1]]], row[2], k))
predictions <- apply(test, 1, predict_helper, Ks)
MAPEs <- apply(predictions, 1, function(pred) mean(abs((pred - test[,3])),na.rm=T))
print(proc.time() - ptm)
predictions
Ks <- seq(1, 2)
predict_helper <- function(row, k) round(predict(ud, ud[[row[1]]], row[2], k))
predictions <- lapply(test, 1, predict_helper, Ks)
predict_helper <- function(row, k) round(predict(ud, ud[[row[1]]], row[2], k))
predictions <- lapply(test, predict_helper, Ks)
predictions
mape_helper <- function(pred, true) mean(abs((pred - true)),na.rm=T)
MAPEs <- apply(predictions, 1, mape_helper, true=test[,3])
View(predictions)
predictions <- tapply(test,  predict_helper, k=Ks)
predictions <- sapply(test, predict_helper, k=Ks)
predictions
predictions <- apply(test, 1, predict_helper, k=Ks)
predictions
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
predictions
View(predictions)
predictions <- apply(test, 2, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
View(ratings)
View(predictions)
View(ratings)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
View(predictions)
predictions[[1]]
predictions[[2]]
predictions[[2]][1]
View(predictions)
Ks <- seq(1, 1)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
predictions
MAPEs <- apply(predictions, 1, function(pred) mean(abs((pred - test[,3])),na.rm=T))
MAPEs <- apply(predictions, 1, function(pred) mean(abs((pred - test[,3])),na.rm=T))
mean(abs((predictions - test[,3])),na.rm=T)
Ks <- seq(1, 2)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
View(predictions)
MAPEs <- apply(predictions, 2, function(pred) {
mean(abs((pred - test[,3])),na.rm=T)
})
predictions[[1]]
apply(predictions[[1]], 2, function(i) i*2)
apply(predictions[[1]], 2, i*2)
apply(predictions[[1]], 2, function(i) i*2)
apply(predictions[[1]], 2, function(i) print(dim(i))
)
predictinos[[1]]
predictions[[1]]
test <- data.frame(matrix(unlist(predictions), nrow=nrow(predictions), byrow=T))
View(predictions)
prediction <- apply(predictions, 1, function(row) {row[1]})
for (row in predictions)
print(row[1])
matrix(, nrow = nrow(predictions), ncol = length(Ks))
matrix(mode="numeric", nrow = nrow(predictions), ncol = length(Ks))
matrix(0, nrow = nrow(predictions), ncol = length(Ks))
matrix(0, nrow = nrow(predictions), ncol =0)
matrix(, nrow = nrow(predictions), ncol =0)
apply(predictions, 2, function(pred) {
mean(abs((pred - test[,3])),na.rm=T)
})
MAPEs <- apply(predictions, 1, function(pred) {
mean(abs((pred - test[,3])),na.rm=T)
})
dim(predictions)
vector()
prediction <- predictions[[1]]
for (row in predictions)
rbind(prediction, row)
prediction
prediction <- predictions[[1]]
for (row in predictions)
prediction <- rbind(prediction, row)
prediction
MAPEs <- apply(prediction, 2, function(pred) {
mean(abs((pred - test[,3])),na.rm=T)
})
nrow(prediction)
nrow(test[,3])
nrow(test)
prediction <- vector()
for (row in predictions)
prediction <- rbind(prediction, row)
nrow(prediction)
MAPEs <- apply(prediction, 2, function(pred) {
mean(abs((pred - test[,3])),na.rm=T)
})
prediction <- vector()
apply(predictions, 1, function(row) prediction <- rbind(prediction, row))
ptm <- proc.time()
Ks <- seq(1, 3)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
# calculate MAPE for different k value
prediction <- vector()
for (row in predictions)
prediction <- rbind(prediction, row)
prediction <- vector()
MAPEs <- apply(prediction, 2, function(pred) {
mean(abs((pred - test[,3])),na.rm=T)
})
print(proc.time() - ptm)
ptm <- proc.time()
Ks <- seq(1, 3)
MAPEs <- vector(mode="numeric", length=0)
for (k in Ks) {
prediction <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], k)))
MAPEs <- c(MAPEs, mean(abs((prediction - test[,3])),na.rm=T))
}
print(proc.time() - ptm)
ptm <- proc.time()
Ks <- seq(1, 3)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
# calculate MAPE for different k value
preds<- vector()
for (row in predictions) preds<- rbind(preds, row)
MAPEs <- apply(preds, 2, function(pred) mean(abs((pred - test[,3])),na.rm=T))
print(proc.time() - ptm)
ptm <- proc.time()
# output minimum MAPE and the k for that
paste("Min MAPE:", min(MAPEs))
paste("Best k found:", 4*which(MAPEs==min(MAPEs)))
optimal_k <- 4*which(MAPEs==min(MAPEs))
print(proc.time() - ptm)
MAPEs
ptm <- proc.time()
# output minimum MAPE and the k for that
paste("Min MAPE:", min(MAPEs))
paste("Best k found:", which(MAPEs==min(MAPEs)))
optimal_k <- which(MAPEs==min(MAPEs))
print(proc.time() - ptm)
ptm <- proc.time()
Ks <- seq(1, 3)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
# calculate MAPE for different k value
preds<- vector()
for (row in predictions) preds<- rbind(preds, row)
MAPEs <- apply(preds, 2, function(pred) mean(abs((pred - test[,3])),na.rm=T))
print(proc.time() - ptm)
Ks <- seq(1, 100, 4)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
preds<- vector()
for (row in predictions) preds<- rbind(preds, row)
MAPEs <- apply(preds, 2, function(pred) mean(abs((pred - test[,3])),na.rm=T))
print(proc.time() - ptm)
ptm <- proc.time()
# output minimum MAPE and the k for that
paste("Min MAPE:", min(MAPEs))
k_loc <- which(MAPEs==min(MAPEs))
optimal_k <- ifelse(k_loc > 1, 4*k_loc, k_loc)
paste("Best k found:", k_loc)
print(proc.time() - ptm)
library('ggplot2')
print("- Creating graphs for MAPE vs K...")
mape_vs_k <- data.frame(k=Ks, mape=MAPEs)
qplot(x=Ks, y=MAPEs, data=mape_vs_k, geom="line")
ggsave('mean_vs_k.png')
Ks <- seq(1, 200, 4)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
preds<- vector()
for (row in predictions) preds<- rbind(preds, row)
MAPEs <- apply(preds, 2, function(pred) mean(abs((pred - test[,3])),na.rm=T))
print(proc.time() - ptm)
ptm <- proc.time()
# output minimum MAPE and the k for that
paste("Min MAPE:", min(MAPEs))
k_loc <- which(MAPEs==min(MAPEs))
optimal_k <- ifelse(k_loc > 1, 4*k_loc, k_loc)
paste("Best k found:", k_loc)
print(proc.time() - ptm)
paste("Min MAPE:", min(MAPEs))
k_loc <- which(MAPEs==min(MAPEs))
optimal_k <- ifelse(k_loc > 1, 4*k_loc, k_loc)
print("Best k found:")
print(k_loc)
which(MAPEs==min(MAPEs))
k_loc > 1
paste("Min MAPE:", min(MAPEs))
k_loc <- which(MAPEs==min(MAPEs))
if (length(k_loc > 1)) optimal_k <- k_loc[1]
else optimal_k <- k_loc
if (length(k_loc > 1))
optimal_k <- k_loc[1]
else
optimal_k <- k_loc
optimal_k <- k_loc
if (length(k_loc > 1))
optimal_k <- k_loc[1]
paste("Min MAPE:", min(MAPEs))
k_loc <- which(MAPEs==min(MAPEs))
optimal_k <- ifelse(k_loc > 1, 4*k_loc, k_loc)
print("Best k found:")
print(optimal_k)
paste("Min MAPE:", min(MAPEs))
k_loc <- which(MAPEs==min(MAPEs))
optimal_k <- ifelse(k_loc > 1, 4*k_loc, k_loc)
print("Best k found:")
print(optimal_k[1])
library('ggplot2')
print("- Creating graphs for MAPE vs K...")
mape_vs_k <- data.frame(k=Ks, mape=MAPEs)
qplot(x=Ks, y=MAPEs, data=mape_vs_k, geom="line")
ggsave('mean_vs_k.png')
tsa <- c(1)
tsa[1]
tsa <- 1
tsa[1]
sep(1,10,2)
sep(1,10,by=2)
seq(1,10,2)
seq(1,10,3)
seq(0,10,3)
seq(1,10,2)
seq(1,10,3)
seq(1,10,5)
seq(1,10,length.out=5)
seq(1,10,length.out=4)
paste("Min MAPE:", min(MAPEs))
k_loc <- which(MAPEs==min(MAPEs))
optimal_k <- k_loc[1]
print("Best k found:")
print(Ks[optimal_k])
seq(1,24,3)
seq(1,24,2)
seq(1,24,5)
seq(1,24,6)
seq(1,24,3)
seq(1,24,length.out=6)
seq(1,24,length.out=5)
seq(1,24,length.out=4)
seq(1,24,length.out=9)
seq(1,24,by=3)
seq(1,25,by=3)
seq(1,30,by=3)
seq(1,30,by=2)
seq(1,30,by=3)
seq(1,30,by=4)
seq(1,30,by=5)
seq(1,30,by=11)
seq(1,30,by=1)
seq(1,30,by=2)
seq(1,29,by=2)
seq(1,24,by=2)
seq(1,25,by=2)
seq(1,30,by=2)
seq(1,30,by=3)
Ks <- seq(1, 240, by=3)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
preds<- vector()
for (row in predictions) preds<- rbind(preds, row)
MAPEs <- apply(preds, 2, function(pred) mean(abs((pred - test[,3])), na.rm=T))
# output first minimum MAPE and the k for that
paste("Min MAPE:", min(MAPEs))
k_loc <- which(MAPEs==min(MAPEs))
optimal_k <- k_loc[1]
print("Best k found:")
print(Ks[optimal_k])
paste("Min MAPE:", min(MAPEs))
k_loc <- which(MAPEs==min(MAPEs))
optimal_k <- Ks[k_loc[1]]
print("Best k found:")
print(optimal_k)
library('ggplot2')
print("- Creating graphs for MAPE vs K...")
mape_vs_k <- data.frame(k=Ks, mape=MAPEs)
qplot(x=Ks, y=MAPEs, data=mape_vs_k, geom="line")
ggsave('mean_vs_k.png')
Ks <- seq(1, 300, by=3)
predictions <- apply(test, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], Ks)))
preds<- vector()
for (row in predictions) preds<- rbind(preds, row)
MAPEs <- apply(preds, 2, function(pred) mean(abs((pred - test[,3])), na.rm=T))
# output first minimum MAPE and the k for that
paste("Min MAPE:", min(MAPEs))
k_loc <- which(MAPEs==min(MAPEs))
optimal_k <- Ks[k_loc[1]]
print("Best k found:")
print(optimal_k)
# using ggplot2 to graph the MAPE vs k line plot
library('ggplot2')
print("- Creating graphs for MAPE vs K...")
mape_vs_k <- data.frame(k=Ks, mape=MAPEs)
qplot(x=Ks, y=MAPEs, data=mape_vs_k, geom="line")
ggsave('mean_vs_k.png')
# using ggplot2 to graph the MAPE vs k line plot
library('ggplot2')
print("- Creating graphs for MAPE vs K...")
mape_vs_k <- data.frame(k=Ks, mape=MAPEs)
qplot(x=Ks, y=MAPEs, data=mape_vs_k, geom="line")
ggsave('mape_vs_k.png')
ud <- formUserData(train_df[,1:3]) # train the whole dataset after evaluation
test_df[,3] <- apply(test_df, 1, function(row) round(predict(ud, ud[[row[1]]], row[2], optimal_k)))
# fill the missing votes
completeRating <- ratings
for (i in 1:nrow(test_df)) {
voterID <- test_df[i,1]
billID <- test_df[i,2]
vote <- test_df[i,3]
completeRating[voterID, billID] <- ifelse(vote==2, 'n', 'y')
}
View(ratings)
View(completeRating)
# fill the missing votes using optimal-knn prediction
knn_filled_data <- ratings
for (i in 1:nrow(test_df)) {
voterID <- test_df[i,1]
billID <- test_df[i,2]
vote <- test_df[i,3]
knn_filled_data[voterID, billID] <- ifelse(vote==2, 'n', 'y')
}
View(knn_filled_data)
# fill the missing votes using optimal-knn prediction
knn_filled_data <- ratings
for (i in 1:nrow(test_df)) {
voterID <- test_df[i,1]
billID <- test_df[i,2]
vote <- test_df[i,3]
knn_filled_data[voterID, billID] <- ifelse(vote==2, 'n', 'y')
}
write.table(knn_filled_data, "knn-filled-data.txt", sep=",")
mfout <- trainReco(train)
preds.mf <- predict(mfout, test[,-3])
mean(abs(preds.mf - test[,3]), na.rm = T)
mfout <- trainReco(train, nmf=T)
set.seed(123)
trainIdx <- sample(seq_len(nrow(train_df)), size=floor(0.80 * nrow(train_df)))
train <- train_df[trainIdx,]
test <- train_df[-trainIdx,]
mfout <- trainReco(train, nmf=T)
?trainReco
set.seed(123)
trainIdx <- sample(seq_len(nrow(train_df)), size=floor(0.80 * nrow(train_df)))
train <- train_df[trainIdx,-4]
test <- train_df[-trainIdx,-4]
mfout <- trainReco(train, nmf=T)
set.seed(123)
trainIdx <- sample(seq_len(nrow(train_df)), size=floor(0.80 * nrow(train_df)))
train <- train_df[trainIdx,]
test <- train_df[-trainIdx,]
mfout <- trainReco(train[1:3], nmf=T)
preds.mf <- predict(mfout, test[,1:2])
mean(abs(preds.mf - test[,3]), na.rm = T)
View(test_df)
View(predictions)
View(train_df)
mfout <- trainReco(train[1:3])
mean(abs(preds.mf - test[,3]), na.rm = T)
preds.mf <- predict(mfout, test[,1:2])
mean(abs(preds.mf - test[,3]), na.rm = T)
mfout <- trainReco(train[1:3],na.rm = T)
train_df[1,] == 249
train_df[,1] == 249
sum(train_df[,1] == 249)
which(train_df[,1] == 249)
which(train_df[,2] == NA)
which(train_df[,2] == 'NA)
''
dssf;
sf
;fs.
)
;
;
;
:q
quit
quickplot()
